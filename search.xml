<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机组成与设计(硬件/软件接口)</title>
    <url>/2020/11/13/computer-organization/</url>
    <content><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><h2 id="计算应用的分类与其特性"><a href="#计算应用的分类与其特性" class="headerlink" title="计算应用的分类与其特性"></a>计算应用的分类与其特性</h2><p>计算机主要包括以下三类应用：  </p>
<ol>
<li><p>个人计算机<br>个人计算机强调为单用户提供良好的性能，价格低廉，通常运行第三方软件   </p>
</li>
<li><p>服务器<br>过去被称为大型机的现代形式，通常借助网络访问。服务器适用于执行大负载任务，可以执行单个复杂应用(科学的或工程的)，也可以处理大量的简单作业，如大型Web服务器。这些应用通常基于其他第三方软件(如数据库和仿真软件)，并且往往为了特别的需要而加以修改和定制。   </p>
<blockquote>
<p>服务器：用于多用户运行大型程序的计算机，通常由多个用户并行使用，并且一般通过网络访问   </p>
</blockquote>
</li>
<li><p>嵌入式计算机<br>数量最多的一类计算机。嵌入式计算机系统的设计目标是运行单一应用程序或者一组相关的应用程序，并且通常和硬件集成在一起以单一系统的方式一并交给用户。<br>面对单一应用需求的嵌入式应用通常对成本和功耗有着严格限制。除此之外，降低成本和功耗是最大目标。嵌入式开发对故障非常敏感。   </p>
<h2 id="后PC时代"><a href="#后PC时代" class="headerlink" title="后PC时代"></a>后PC时代</h2></li>
</ol>
<ul>
<li>个人移动设备(Personal Mobile Device,PMD):连接到网络上的小型无线设备。PMD由电池供电，通过下载APP的方式安装软件。智能手机和平板电脑就是典型的PMD。  </li>
<li>云计算(colud computing):云计算代替了传统服务器，它依赖于称为<strong>仓储规模计算机</strong>(Warehouse Scale Computer,WSC)的举行数据中心。通过云计算实现的<strong>软件即服务</strong>(Software as a Service,SaaS)是软件工业的一次革命。     <blockquote>
<p>云计算：在网络上提供服务的大服务器集群，一些运营商根据应用需求出租不同数量的服务器。<br>软件即服务：在网络上以服务方式提供软件和数据。其运行方式通常不是在本地设备上运行所有二进制代码，而是通过诸如运行在本地服务器的浏览器等小程序登陆到远端服务器上执行。典型例子是Web搜索和社交网络。   </p>
</blockquote>
</li>
</ul>
<h2 id="计算机系统结构中的8个伟大思想"><a href="#计算机系统结构中的8个伟大思想" class="headerlink" title="计算机系统结构中的8个伟大思想"></a>计算机系统结构中的8个伟大思想</h2><h3 id="面向摩尔定律的设计"><a href="#面向摩尔定律的设计" class="headerlink" title="面向摩尔定律的设计"></a>面向摩尔定律的设计</h3><p>计算机设计者面临的一个永恒的问题就是摩尔定律驱动的快速变化。摩尔定律（英语：ore’s law）是由英特尔创始人之一戈登·摩尔提出的。其内容为：集成电路上可容纳的晶体管数目，约每隔18~24个月便会增加一倍。由于计算机设计者设计需要画几年时间，因此在项目结束时，单芯片的集成度相对于设计开始时很容易翻上一番，因此计算机设计者必须预测其设计完成时的工艺水平，而不是设计开始时的。    </p>
<h3 id="使用抽象简化设计"><a href="#使用抽象简化设计" class="headerlink" title="使用抽象简化设计"></a>使用抽象简化设计</h3><p>提高硬件和软件生产率的主要技术之一是使用<strong>抽象</strong>来表示不同的设计层次，在高层次中看不到低层次的细节，只能看到一个简化的模型。  </p>
<h3 id="加速大概率事件"><a href="#加速大概率事件" class="headerlink" title="加速大概率事件"></a>加速大概率事件</h3><p>加速大概率事件远比优化小概率事件跟能提高性能。大概率事件通常比小概率事件简单，从而易于提升。大概率事件规则意味着设计者需要知道什么事件是经常发生的，这只有经过仔细地实验和评估才能得到。   </p>
<h3 id="通过并行提高性能"><a href="#通过并行提高性能" class="headerlink" title="通过并行提高性能"></a>通过并行提高性能</h3><h3 id="通过流水线提高性能"><a href="#通过流水线提高性能" class="headerlink" title="通过流水线提高性能"></a>通过流水线提高性能</h3><h3 id="通过预测提高性能"><a href="#通过预测提高性能" class="headerlink" title="通过预测提高性能"></a>通过预测提高性能</h3><h3 id="存储器层次"><a href="#存储器层次" class="headerlink" title="存储器层次"></a>存储器层次</h3><h3 id="通过冗余提高可靠性"><a href="#通过冗余提高可靠性" class="headerlink" title="通过冗余提高可靠性"></a>通过冗余提高可靠性</h3><h2 id="程序概念入门"><a href="#程序概念入门" class="headerlink" title="程序概念入门"></a>程序概念入门</h2><p>计算机中的硬件只能执行极为简单的低级指令。从复杂应用程序到简单的指令需要经过几个软件层次来将复杂的高层次操作逐渐解释或翻译成简单的计算机指令，这可以作为<strong>抽象</strong>思想的一个例子。<br>下图给出了这些软件的层次结构，外层是应用软件，中间是硬件，<strong>系统软件</strong>位于两者之间。  </p>
<blockquote>
<p>系统软件：提供常用服务的软件，包括操作系统、编译程序、加载程序和汇编程序的。    </p>
</blockquote>
<p><img src="https://s3.ax1x.com/2020/11/13/D9KU9s.png" alt="简化的硬件软件层次图"><br>系统软件有很多种，其中两种对于现代计算机系统来说是必需的：操作系统和汇编程序。<br><strong>操作系统</strong>是用户程序和硬件的接口，为用户提供各种服务和监控功能。<br><strong>编译程序</strong>：将高级语言翻译成计算机所能识别的机器语言的程序。   </p>
<h3 id="从高级语言到硬件语言"><a href="#从高级语言到硬件语言" class="headerlink" title="从高级语言到硬件语言"></a>从高级语言到硬件语言</h3><p>汇编程序：将指令由助记符形式翻译成二进制形式的程序。<br>汇编语言：以助记符形式表示的机器指令。<br>机器语言：以二进制形式表示的机器指令集。  </p>
<blockquote>
<p>助记符（mnemonic）是便于人们记忆、并能描述指令功能和指令操作数的符号，助记符是表明指令功能的英语单词或其缩写。<br>汇编语言由于采用了助记符号来编写程序，比用机器语言的二进制代码编程要方便些，在一定程度上简化了编程过程。汇编语言的特点是用符号代替了机器指令代码，而且助记符与指令代码一一对应，基本保留了机器语言的灵活性。使用汇编语言能面向机器并较好地发挥机器的特性，得到质量较高的程序。</p>
</blockquote>
<p><strong>高级编程语言</strong>及其编译程序的出现大大地提高了软件的生产率。这是<strong>抽象</strong>的另一个例子<br>下图表示了程序语言之间的关系<br><img src="https://s3.ax1x.com/2020/11/13/D9K4u6.png" alt="程序语言之间的关系 "></p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>响应时间：也叫执行时间，是计算机完成某个任务所需的总时间，包括磁盘访问、内存访问、I/O活动、操作系统开销和CPU执行时间。<br>吞吐量：也称带宽，性能的另一参考参数，表示单位时间内完成的任务的数量。  </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes入门</title>
    <url>/2020/11/29/Kubernetes/</url>
    <content><![CDATA[<h1 id="什么是Kubernetes？"><a href="#什么是Kubernetes？" class="headerlink" title="什么是Kubernetes？"></a>什么是Kubernetes？</h1><p>Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。    </p>
<h2 id="为什么需要k8s？"><a href="#为什么需要k8s？" class="headerlink" title="为什么需要k8s？"></a>为什么需要k8s？</h2><p>容器是打包和运行应用程序的好方式。在生产环境中，你需要管理运行应用程序的容器，并确保不会停机。 例如，如果一个容器发生故障，则需要启动另一个容器。如果系统处理此行为，会不会更容易？</p>
<p>这就是 Kubernetes 来解决这些问题的方法！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。</p>
<p>Kubernetes 为你提供：</p>
<ul>
<li><p>服务发现和负载均衡<br>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p>
</li>
<li><p>存储编排<br>Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</p>
</li>
<li><p>自动部署和回滚<br>你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</p>
</li>
<li><p>自动完成装箱计算<br>Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</p>
</li>
<li><p>自我修复<br>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。     </p>
</li>
</ul>
<p>以上内容转自k8s官方文档：<a href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-kubernetes-%E5%AE%83%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88">https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-kubernetes-%E5%AE%83%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88</a>       </p>
<h1 id="k8s架构组件"><a href="#k8s架构组件" class="headerlink" title="k8s架构组件"></a>k8s架构组件</h1><p><img src="https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg" alt="完整架构图"><br>部分详解：   </p>
<h2 id="控制平面组件（Control-Plane-Components）"><a href="#控制平面组件（Control-Plane-Components）" class="headerlink" title="控制平面组件（Control Plane Components）"></a>控制平面组件（Control Plane Components）</h2><p>即master node</p>
<h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><p>API 服务器是 Kubernetes 控制面的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。</p>
<p>Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。     </p>
<blockquote>
<p>集群统一入口，以restful风格进行操作，同时交给etcd存储<br>提供认证、授权、访问控制、API注册和发现等机制     </p>
</blockquote>
<h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><p>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。     </p>
<blockquote>
<p>存储系统，用于保存集群中的相关数据    </p>
</blockquote>
<h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><p>主节点上的组件，该组件监视那些新创建的未指定运行节点的 Pod，并选择节点让 Pod 在上面运行。</p>
<p>调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。   </p>
<blockquote>
<p>节点的调度，选择node节点应用部署          </p>
</blockquote>
<h3 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h3><p>在主节点上运行控制器的组件。  </p>
<p>从逻辑上讲，每个控制器都是一个单独的进程，但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。  </p>
<p>这些控制器包括:</p>
<ul>
<li>节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。</li>
<li>副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。</li>
<li>端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。<br>服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌.   </li>
</ul>
<blockquote>
<p>处理集群中常规后台任务，一个资源对应一个控制器    </p>
</blockquote>
<h3 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager</h3><p>云控制器管理器是 1.8 的 alpha 特性。在未来发布的版本中，这是将 Kubernetes 与任何其他云集成的最佳方式。<br>cloud-controller-manager 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。</p>
<p>与 kube-controller-manager 类似，cloud-controller-manager 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p>
<p>下面的控制器都包含对云平台驱动的依赖：</p>
<ul>
<li>节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除</li>
<li>路由控制器（Route Controller）: 用于在底层云基础架构中设置路由</li>
<li>服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器    </li>
</ul>
<h2 id="Node组件"><a href="#Node组件" class="headerlink" title="Node组件"></a>Node组件</h2><p>节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。   </p>
<h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p>一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。</p>
<p>kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。kubelet 不会管理不是由 Kubernetes 创建的容器。      </p>
<h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><p>kube-proxy 是集群中每个节点上运行的网络代理,实现 Kubernetes Service 概念的一部分。</p>
<p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p>
<p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy会通过它来实现网络规则。否则，kube-proxy 仅转发流量本身。     </p>
<h2 id="容器运行时（Container-Runtime）"><a href="#容器运行时（Container-Runtime）" class="headerlink" title="容器运行时（Container Runtime）"></a>容器运行时（Container Runtime）</h2><p>容器运行环境是负责运行容器的软件。</p>
<p>Kubernetes 支持多个容器运行环境: docker、 containerd、CRI-O 以及任何实现 Kubernetes CRI (容器运行环境接口)。      </p>
<h1 id="k8s核心概念"><a href="#k8s核心概念" class="headerlink" title="k8s核心概念"></a>k8s核心概念</h1><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><ul>
<li>Pod是K8s中最小部署单元</li>
<li>一组容器的集合</li>
<li>共享网络【一个Pod中的所有容器共享同一网络】</li>
<li>生命周期是短暂的（服务器重启后，就找不到了）</li>
</ul>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><ul>
<li>确保预期的pod副本数量【ReplicaSet】</li>
<li>无状态应用部署【Depoltment】,无状态就是指，不需要依赖于网络或者ip</li>
<li>有状态应用部署【StatefulSet】,有状态需要特定的条件</li>
<li>确保所有的node运行同一个pod 【DaemonSet】</li>
<li>一次性任务和定时任务【Job和CronJob】</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><ul>
<li>定义一组pod的访问规则</li>
<li>Pod的负载均衡，提供一个或多个Pod的稳定访问地址</li>
<li>支持多种方式【ClusterIP、NodePort、LoadBalancer】    </li>
</ul>
<h1 id="搭建k8s集群"><a href="#搭建k8s集群" class="headerlink" title="搭建k8s集群"></a>搭建k8s集群</h1><h2 id="搭建k8s环境平台规划"><a href="#搭建k8s环境平台规划" class="headerlink" title="搭建k8s环境平台规划"></a>搭建k8s环境平台规划</h2><ul>
<li>单master集群<br><img src="https://s3.ax1x.com/2020/11/29/DgKzgx.png" alt="单master集群">      </li>
<li>多master集群<br><img src="https://s3.ax1x.com/2020/11/29/DgM4de.png" alt="DgM4de.png">   </li>
</ul>
<h2 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h2><p>测试环境   </p>
<ul>
<li>master<br>2核 4G 20G   </li>
<li>Node<br>4核 8G 40G  </li>
</ul>
<h2 id="搭载k8s集群部署方式"><a href="#搭载k8s集群部署方式" class="headerlink" title="搭载k8s集群部署方式"></a>搭载k8s集群部署方式</h2><p>目前搭建k8s集群主要有两种方式：kuberadm和二进制包   </p>
<ul>
<li>kuberadm<br>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。    </li>
</ul>
<p>这个工具能通过两条指令完成一个kubernetes集群的部署： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个 Master 节点  </span></span><br><span class="line">kubeadm init  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 将一个 Node 节点加入到当前集群中   </span></span><br><span class="line">kubeadm join &lt;Master节点的IP和端口 &gt;   </span><br></pre></td></tr></table></figure>

<ul>
<li>二进制包<br>从github下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。    </li>
</ul>
<h3 id="使用kuberadm搭建k8s集群"><a href="#使用kuberadm搭建k8s集群" class="headerlink" title="使用kuberadm搭建k8s集群"></a>使用kuberadm搭建k8s集群</h3><ol>
<li>使用2台以上服务器（或虚拟机）   </li>
<li>对操作系统进行初始化操作   </li>
</ol>
<pre><code class="shell"># 关闭防火墙
systemctl stop firewalld
systemctl disable firewalld

# 关闭selinux
# 永久关闭
sed -i &#39;s/enforcing/disabled/&#39; /etc/selinux/config  
# 临时关闭
setenforce 0  

# 关闭swap
# 临时
swapoff -a 
# 永久关闭
sed -ri &#39;s/.*swap.*/#&amp;/&#39; /etc/fstab

# 根据规划设置主机名【master节点上操作】
hostnamectl set-hostname k8smaster
# 根据规划设置主机名【node1节点操作】
hostnamectl set-hostname k8snode1

# 在master添加hosts
# 这里为你的ip
cat &gt;&gt; /etc/hosts &lt;&lt; EOF
39.102.44.60 k8smaster
10.0.4.246 k8snode
EOF


# 将桥接的IPv4流量传递到iptables的链
cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
# 生效
sysctl --system  

# 时间同步
apt install ntpdate -y
ntpdate time.windows.com   </code></pre>
<ol start="3">
<li><p>安装Docker<br>见上一篇博客     </p>
</li>
<li><p>添加kubernetes软件源<br>配置ubuntu的k8s软件源   </p>
</li>
</ol>
<pre><code class="shell">curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -
cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list
deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main
EOF</code></pre>
<ol start="5">
<li>安装kubeadm，kubelet和kubectl    </li>
</ol>
<pre><code class="shell"># 安装kubelet、kubeadm、kubectl
apt-get install -y kubelet kubeadm kubectl  
# 设置开机启动
systemctl enable kubelet      </code></pre>
]]></content>
      <categories>
        <category>项目开发基础</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2020/10/21/docker/</url>
    <content><![CDATA[<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>系统版本：Ubuntu20.04<br>官方文档：<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a></p>
<ol>
<li><p>卸载旧版本(如没有则跳过)<br><code>sudo apt-get remove docker docker-engine docker.io containerd runc </code></p>
</li>
<li><p>更新apt并下载相关包  </p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update  </span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">apt-transport-https \</span><br><span class="line">ca-certificates \</span><br><span class="line">curl \</span><br><span class="line">gnupg-agent \</span><br><span class="line">software-properties-common</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>添加Docker官方GPG key<br><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code>  </p>
</li>
<li><p>验证你拥有了key<br><code>sudo apt-key fingerprint 0EBFCD88</code></p>
</li>
</ol>
<blockquote>
<p>pub   rsa4096 2017-02-22 [SCEA]<br>    9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88<br>uid                 [ unknown] Docker Release (CE deb) <a href="mailto:&#100;&#x6f;&#x63;&#107;&#x65;&#114;&#64;&#x64;&#x6f;&#99;&#107;&#x65;&#x72;&#46;&#x63;&#111;&#109;">&#100;&#x6f;&#x63;&#107;&#x65;&#114;&#64;&#x64;&#x6f;&#99;&#107;&#x65;&#x72;&#46;&#x63;&#111;&#109;</a><br>sub   rsa4096 2017-02-22 [S]    </p>
</blockquote>
<ol start="5">
<li>使用以下命令设置稳定存储库。(这里为x86_64/amd64)   </li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line"><span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string"><span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">stable&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>安装最新版Docker   </li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可指定版本  </p>
</blockquote>
<p><code>apt-cache madison docker-ce  </code>   </p>
<blockquote>
<p>docker-ce | 5:18.09.1<del>3-0</del>ubuntu-xenial | <a href="https://download.docker.com/linux/ubuntu">https://download.docker.com/linux/ubuntu</a>  xenial/stable amd64 Packages<br>  docker-ce | 5:18.09.0<del>3-0</del>ubuntu-xenial | <a href="https://download.docker.com/linux/ubuntu">https://download.docker.com/linux/ubuntu</a>  xenial/stable amd64 Packages<br>  docker-ce | 18.06.1<del>ce</del>3-0<del>ubuntu       | <a href="https://download.docker.com/linux/ubuntu">https://download.docker.com/linux/ubuntu</a>  xenial/stable amd64 Packages<br>  docker-ce | 18.06.0</del>ce<del>3-0</del>ubuntu       | <a href="https://download.docker.com/linux/ubuntu">https://download.docker.com/linux/ubuntu</a>  xenial/stable amd64 Packages<br>  …    </p>
</blockquote>
<p><code>sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</code></p>
<blockquote>
<p>​    例如<br><code>sudo apt-get install docker-ce=&lt;5:18.09.1~3-0~ubuntu-xenial&gt; docker-ce-cli=&lt;5:18.09.1~3-0~ubuntu-xenial&gt; containerd.io</code>     </p>
</blockquote>
<ol start="7">
<li><p>通过运行hello-world映像，验证Docker引擎已正确安装。<br><code>sudo docker run hello-world</code><br><img src="https://s1.ax1x.com/2020/10/21/BPN3VS.png" alt="hello-world">  </p>
</li>
<li><p>设置开机自启<br><code>sudo systemctl enable docker</code><br>关闭开机自启<br><code>sudo systemctl disable docker</code>   </p>
</li>
<li><p>查看Docker运行情况<br><code>sudo systemctl status docker</code>    </p>
<h1 id="Docker的中央仓库"><a href="#Docker的中央仓库" class="headerlink" title="Docker的中央仓库"></a>Docker的中央仓库</h1></li>
<li><p>Docker的官方仓库  </p>
<blockquote>
<p><a href="https://hub.docker.com/">https://hub.docker.com/</a>   </p>
</blockquote>
</li>
<li><p>国内镜像仓库  </p>
</li>
</ol>
<ul>
<li><p>网易蜂巢  </p>
<blockquote>
<p><a href="https://c.163yun.com/hub#/home">https://c.163yun.com/hub#/home</a>   </p>
</blockquote>
</li>
<li><p>daocloud   </p>
<blockquote>
<p><a href="https://hub.daocloud.io/">https://hub.daocloud.io/</a>   </p>
</blockquote>
</li>
</ul>
<h1 id="镜像的操作"><a href="#镜像的操作" class="headerlink" title="镜像的操作"></a>镜像的操作</h1><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p><code>docker pull 镜像名称[:tag]</code>  </p>
<blockquote>
<p>tag表示具体版本(可写可不写)   </p>
</blockquote>
<p>拉取tomcat环境(daocloud)<br><code>docker pull daocloud.io/library/tomcat:8.5.15-jre8 </code><br><img src="https://s1.ax1x.com/2020/10/21/BPdzdK.png" alt="地址"></p>
<h2 id="查看本地全部的镜像"><a href="#查看本地全部的镜像" class="headerlink" title="查看本地全部的镜像"></a>查看本地全部的镜像</h2><p><code>docker images</code><br><img src="https://s1.ax1x.com/2020/10/21/BPwRYD.png" alt="全部镜像"></p>
<h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p><code>docker rmi [IMAGE ID]</code>   </p>
<h2 id="镜像的导入导出"><a href="#镜像的导入导出" class="headerlink" title="镜像的导入导出"></a>镜像的导入导出</h2><ul>
<li>导出<br><code>docker save -o [src] [IMAGE ID]</code>  </li>
<li>加载<br><code>docker load -i [镜像文件]</code> </li>
<li>修改镜像名称<br><code>docker tag [IMAGE ID] [名称:版本]</code>   <h1 id="容器的操作"><a href="#容器的操作" class="headerlink" title="容器的操作"></a>容器的操作</h1><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2></li>
<li>简单语法<br><code>docker run [IMAGE ID]|[镜像名称[:tag]]</code>   </li>
<li>常用语法<br><code>docker run -d -p 宿主机端口:容器端口 --name 容器名称 [IMAGE ID]|[镜像名称[:tag]]</code>   <blockquote>
<p>-d: 后台运行容器  </p>
</blockquote>
</li>
</ul>
<p>-p: 宿主机端口:容器端口  :映射当前Linux的端口和容器的端口<br>–name  容器名称： 指定容器的名称  </p>
<ul>
<li><p>运行已有容器<br><code>docker start [container_ID]</code>   </p>
</li>
<li><p>例如<br><code>docker run -dit -p 8080:8080 --name tomcat b8</code>   </p>
<h2 id="查看运行的容器"><a href="#查看运行的容器" class="headerlink" title="查看运行的容器"></a>查看运行的容器</h2><p><code>docker ps [-q|-a]</code></p>
<blockquote>
<p>-a: 查看全部容器，包括没有运行的容器   </p>
</blockquote>
</li>
</ul>
<p>-q:  只查看容器的标识(IMAGE ID)</p>
<h2 id="查看容器的日志"><a href="#查看容器的日志" class="headerlink" title="查看容器的日志"></a>查看容器的日志</h2><p><code>docker logs -f [IMAGE ID]</code>   </p>
<blockquote>
<p>-f: 可以滚动日志的最后几行    </p>
</blockquote>
<h2 id="进入容器内部"><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h2><p>`docker exec -it [container_ID] /bin/bash    </p>
<h2 id="停止和删除容器-删除容器前需要先停止容器"><a href="#停止和删除容器-删除容器前需要先停止容器" class="headerlink" title="停止和删除容器(删除容器前需要先停止容器)"></a>停止和删除容器(删除容器前需要先停止容器)</h2><ul>
<li>停止指定的容器<br><code>docker stop [container_ID]</code>  </li>
<li>停止所用容器<br><code>docker stop $(docker ps -qa)</code></li>
<li>删除指定的容器<br><code>docker rm [container_ID]</code>   </li>
<li>删除所有容器<br><code>docker rm $(docker ps -qa)</code>    </li>
</ul>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p><code>docker start [container_ID]</code>   </p>
<h1 id="应用Docker-以golang环境为例"><a href="#应用Docker-以golang环境为例" class="headerlink" title="应用Docker(以golang环境为例)"></a>应用Docker(以golang环境为例)</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="拉取镜像-1"><a href="#拉取镜像-1" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p><code>docker pull golang</code>  </p>
<h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><p><code>docker images</code><br><img src="https://s1.ax1x.com/2020/10/22/BkMl26.png">  </p>
<h3 id="运行容器-1"><a href="#运行容器-1" class="headerlink" title="运行容器"></a>运行容器</h3><p><code>docker run -dit -name golang 4a</code><br><img src="https://s1.ax1x.com/2020/10/22/BkMvz6.png"><br>输入<code>docker ps</code>发现容器已经运行   </p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p><code>docker exec -it 88 /bin/bash</code><br>输入<code>go version</code>发现环境已成功运行<br><img src="https://s1.ax1x.com/2020/10/22/BkQO0g.png">   </p>
<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><p> <code>exit</code>  </p>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p> <code>docker stop 88</code>   </p>
<h2 id="使用环境-运行hello-go"><a href="#使用环境-运行hello-go" class="headerlink" title="使用环境(运行hello.go)"></a>使用环境(运行hello.go)</h2><h3 id="在VsCode中配置环境"><a href="#在VsCode中配置环境" class="headerlink" title="在VsCode中配置环境"></a>在VsCode中配置环境</h3><p> 在VsCode中添加以下扩展  </p>
<ul>
<li><p>GO  </p>
</li>
<li><p>Docker  </p>
</li>
<li><p>Docker WorkSpace  </p>
<h3 id="设置Docker试之可以在非root用户下运行"><a href="#设置Docker试之可以在非root用户下运行" class="headerlink" title="设置Docker试之可以在非root用户下运行"></a>设置Docker试之可以在非root用户下运行</h3><ul>
<li>添加docker用户组<br><code>sudo groupadd docker</code>  </li>
<li>将登陆用户加入到docker用户组中<br><code>sudo gpasswd -a $USER docker</code>    </li>
<li>更新用户组<br><code>newgrp docker</code>    </li>
<li>重启系统即可<br><img src="https://s1.ax1x.com/2020/10/23/BECJsI.png">   <h3 id="运行容器-2"><a href="#运行容器-2" class="headerlink" title="运行容器"></a>运行容器</h3><code>docker start 88</code>   </li>
</ul>
<h3 id="将容器添加到VsCode工作区"><a href="#将容器添加到VsCode工作区" class="headerlink" title="将容器添加到VsCode工作区"></a>将容器添加到VsCode工作区</h3></li>
<li><p>打开VcCode按[F1] 输入<code> dockerws: Add Folder to Workspace</code>。接下来，选择docker容器，下一步， 选择要打开的文件夹路径即可。  </p>
</li>
<li><p>打开VsCode资源管理器，发现go已经添加到工作区<br><img src="https://s1.ax1x.com/2020/10/23/BEC0Jg.png">    </p>
<h3 id="新建hello-go文件，写入测试代码"><a href="#新建hello-go文件，写入测试代码" class="headerlink" title="新建hello.go文件，写入测试代码"></a>新建hello.go文件，写入测试代码</h3><p>新建hello.go文件，并写入以下代码，保存。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pakage main</span><br><span class="line"></span><br><span class="line"> <span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行hello-go"><a href="#运行hello-go" class="headerlink" title="运行hello.go"></a>运行hello.go</h3></li>
<li><p>打开VsCode终端  </p>
</li>
<li><p>输入<code>docker exec -it 88 /bin/bash</code>进入容器   </p>
</li>
<li><p>输入<code>go run hello.go</code> </p>
</li>
<li><p>发现输出 hello world 说明hello.go运行成功<br><img src="https://s1.ax1x.com/2020/10/23/BEC6Lq.png"></p>
</li>
</ul>
<h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><h2 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h2><p><code>docker volume create [数据卷名称]</code>  </p>
<blockquote>
<p>默认路径 /var/lib/docker/volumes/数据卷名称<br>数据卷中的具体内容存放在：    /var/lib/docker/volumes/数据卷名称/_data   </p>
</blockquote>
<h2 id="查看数据卷的详细信息"><a href="#查看数据卷的详细信息" class="headerlink" title="查看数据卷的详细信息"></a>查看数据卷的详细信息</h2><ul>
<li>查看指定的数据卷<br><code>docker volume inspect [数据卷名称]</code>   </li>
<li>查看全部数据卷<br><code>docker volume ls</code>  </li>
</ul>
<h2 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h2><p><code>docker volume rm [数据卷名称]</code>   </p>
<h2 id="应用数据卷"><a href="#应用数据卷" class="headerlink" title="应用数据卷"></a>应用数据卷</h2><ul>
<li>当映射数据卷时，若数据卷不存在，Docker会帮你创建<br><code>docker run -v [数据卷名称:容器内部的路径]</code>    </li>
<li>直接指定一个路径作为数据卷的存放位置<br><code>docker run -v [路径:容器内部的路径]</code></li>
</ul>
<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><h2 id="DockerFile是什么？"><a href="#DockerFile是什么？" class="headerlink" title="DockerFile是什么？"></a>DockerFile是什么？</h2><p>DockerFile 是构建Docker镜像的构造文件，是由一系列命令的参数构成的脚本。   </p>
<h2 id="DockerFile基础"><a href="#DockerFile基础" class="headerlink" title="DockerFile基础"></a>DockerFile基础</h2><ul>
<li>dockerfile每条保留字指令都必须为大写字母，且后面要跟随至少一个参数   </li>
<li>指令按照从上到下顺序执行  </li>
<li>#表示注释   </li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交   <h2 id="DockerFile保留关键字"><a href="#DockerFile保留关键字" class="headerlink" title="DockerFile保留关键字"></a>DockerFile保留关键字</h2></li>
<li>FROM ：基础镜像，当前新镜像是基于哪个镜像的   </li>
<li>MAINTAINER ：镜像维护者的姓名的邮箱地址   </li>
<li>RUN ：容器构建时需要与运行的命令   </li>
<li>EXPOSE ：当前容器对外暴露的端口   </li>
<li>WORKDIR ：指定在创建容器后，终端默认登陆进来的工作目录，一个落脚点  </li>
<li>ENV ：用来搭建镜像过程中设置的环境变量  </li>
<li>ADD ：将宿主机目录下的文件拷贝进镜像且ADD命令会自动运行URL和解压tar压缩包  </li>
<li>将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新一层的镜像内的&lt;目标路径&gt;位置<code>COPY src dest</code>   </li>
<li>VOLUME : 容器数据卷，用于保存和持久化工作  </li>
<li>CMD ：指定一个容器启动时运行的命令，DockerFile中可以有多个CMD指令，但只有最后一个生效，CMD会被的的docker run之后的参数替换   </li>
<li>ENTRYPOINT ：指定一个容器启动时运行的命令，ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数。（与CMD不同的是ENTRYPOINT的参数是追加）  </li>
<li>ONBUILD ：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发  <h2 id="DockerFile案例1——自定义镜像golang"><a href="#DockerFile案例1——自定义镜像golang" class="headerlink" title="DockerFile案例1——自定义镜像golang"></a>DockerFile案例1——自定义镜像golang</h2></li>
</ul>
<ol>
<li><p>新建DockerFile文件<br><img src="https://s1.ax1x.com/2020/10/29/BJzVIO.png">   </p>
</li>
<li><p>在DockerFile文件里写入如下内容  </p>
</li>
</ol>
<blockquote>
<p>FROM golang<br>ENV MYPATH /go/bin/<br>WORKDIR $MYPATH<br>EXPOSE 88<br>CMD echo $MYPATH<br>CMD echo “success===========ok”<br>CMD /bin/bash     </p>
</blockquote>
<ol start="3">
<li><p>打开终端输入<code>docker build -f /home/violet/project/mydocker/DockerFile -t mygolang:1.15 .</code>（其中-f后跟你的DockerFile文件的路径），回车<br><img src="https://s1.ax1x.com/2020/10/29/BJzuzd.png">    </p>
</li>
<li><p>输入<code>docker images</code>,发现镜像已经创建成功<br><img src="https://s1.ax1x.com/2020/10/29/BJzlLt.png">   </p>
</li>
<li><p>运行并进入容器，发现已成功设置参数<br><img src="https://s1.ax1x.com/2020/10/29/BJzYFS.png">     </p>
</li>
</ol>
<h1 id="示例——安装MySQL"><a href="#示例——安装MySQL" class="headerlink" title="示例——安装MySQL"></a>示例——安装MySQL</h1><ol>
<li>搜索MySQL镜像<br><code>docker search mysql</code>   </li>
<li>拉取镜像<br><code>docker pull mysql</code><br><img src="https://s1.ax1x.com/2020/10/30/BYBcqO.png">    </li>
<li>运行镜像<br><code>docker run -dit -p 1234:3306 -v /home/violet/project/mysql/conf:/etc/mysql/conf.d -v /home/violet/project/mysql/logs:/logs -v /home/violet/project/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=pass --name mysql db2b</code>    </li>
<li>进入容器<br><code>docker exec -it 112 /bin/bash</code>   </li>
<li>运行<br><code>mysql -uroot -p</code><br><img src="https://s1.ax1x.com/2020/10/30/BYBIzt.png">    </li>
</ol>
<h1 id="本地镜像发布"><a href="#本地镜像发布" class="headerlink" title="本地镜像发布"></a>本地镜像发布</h1><ol>
<li>登陆阿里云 </li>
<li>在阿里云创建本地仓库  </li>
<li>创建之后点击管理，进入管理页面，按照提示输入相应命令，将镜像发布<br><img src="https://s1.ax1x.com/2020/10/30/BYyJfJ.png"><br><img src="https://s1.ax1x.com/2020/10/30/BYycpd.png"><br><img src="https://s1.ax1x.com/2020/10/30/BY68DP.png">   </li>
<li>搜索镜像<br><img src="https://s1.ax1x.com/2020/10/30/BYRUZq.png">  </li>
</ol>
<h1 id="docker-compsoe管理容器"><a href="#docker-compsoe管理容器" class="headerlink" title="docker-compsoe管理容器"></a>docker-compsoe管理容器</h1><h2 id="下载docker-compsoe"><a href="#下载docker-compsoe" class="headerlink" title="下载docker-compsoe"></a>下载docker-compsoe</h2><ol>
<li>去github官网搜索docker-compose   </li>
<li>将docker-compose文件移到到<code>usr/local/</code>目录下<br><code>sudo mv docker-compose-Linux-x86_64 /usr/local/</code>   </li>
<li>重命名docker-compose-Linux-x86_64文件，并给予DockerCompose文件一个可执行的权限<br><code>sudo mv docker-compose-Linux-x86_64 docker-compose</code><br><code>chmod 777 docker-compose</code>   </li>
<li>方便后期操作，配置一个环境变量,将docker-compose文件移动到了/usr/local/bin，修改了/etc/profile文件，给/usr/local/bin配置到了PATH中<br><code>sudo mv docker-compose /usr/local/bin</code><br><code>vi /etc/profile</code><br>添加内容：export PATH=/usr/local/bin:$PATH<br><code>source /etc/profile</code>   </li>
<li>在任意目录下输入<code>docker-compose</code>   </li>
</ol>
<h2 id="Docker-Compose管理MySQL和Tomcat容器"><a href="#Docker-Compose管理MySQL和Tomcat容器" class="headerlink" title="Docker-Compose管理MySQL和Tomcat容器"></a>Docker-Compose管理MySQL和Tomcat容器</h2><ul>
<li>yml文件以key:value方式来指定配置信息   </li>
<li>多个配置信息以换行+缩进的方式来区分    </li>
<li>在docker-compose.yml文件中，不要使用制表符    </li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span>           <span class="comment"># 服务的名称</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>   <span class="comment"># 代表只要docker启动，那么这个容器就跟着一起启动</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">daocloud.io/library/mysql:5.7.4</span>  <span class="comment"># 指定镜像路径</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span>  <span class="comment"># 指定容器名称</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span>   <span class="comment">#  指定端口号的映射</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span>   <span class="comment"># 指定MySQL的ROOT用户登录密码</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span>        <span class="comment"># 指定时区</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">/opt/docker_mysql_tomcat/mysql_data:/var/lib/mysql</span>   <span class="comment"># 映射数据卷</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">daocloud.io/library/tomcat:8.5.15-jre8</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker_mysql_tomcat/tomcat_webapps:/usr/local/tomcat/webapps</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/docker_mysql_tomcat/tomcat_logs:/usr/local/tomcat/logs</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用docker-compose命令管理容器"><a href="#使用docker-compose命令管理容器" class="headerlink" title="使用docker-compose命令管理容器"></a>使用docker-compose命令管理容器</h2><p>在使用docker-compose的命令时，默认会在当前目录下找docker-compose.yml文件</p>
<ol>
<li><p>基于docker-compose.yml启动管理的容器<br> <code>docker-compose up -d  </code> </p>
</li>
<li><p>关闭并删除容器<br> <code>docker-compose down</code></p>
</li>
<li><p>开启|关闭|重启已经存在的由docker-compose维护的容器<br> <code>docker-compose start|stop|restart </code> </p>
</li>
<li><p>查看由docker-compose管理的容器<br> <code>docker-compose ps</code>   </p>
</li>
<li><p>查看日志<br> <code>docker-compose logs -f</code>  </p>
</li>
</ol>
<h2 id="docker-compose配合Dockerfile使用"><a href="#docker-compose配合Dockerfile使用" class="headerlink" title="docker-compose配合Dockerfile使用"></a>docker-compose配合Dockerfile使用</h2><p>使用docker-compose.yml文件以及Dockerfile文件在生成自定义镜像的同时启动当前镜像，并且由docker-compose去管理容器    </p>
<ol>
<li>编写docker-compose文件   </li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">ssm:</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">build:</span>            <span class="comment"># 构建自定义镜像</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">../</span>      <span class="comment"># 指定dockerfile文件的所在路径</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span>   <span class="comment"># 指定Dockerfile文件名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ssm:1.0.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ssm</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>编写Dockerfile文件   </p>
<blockquote>
<p>from daocloud.io/library/tomcat:8.5.15-jre8<br>copy ssm.war /usr/local/tomcat/webapps  </p>
</blockquote>
</li>
<li><p>运行<br>可以直接基于docker-compose.yml以及Dockerfile文件构建的自定义镜像<br><code>docker-compose up -d</code><br>如果自定义镜像不存在，会帮助我们构建出自定义镜像，如果自定义镜像已经存在，会直接运行这个自定义镜像<br>重新构建自定义镜像<br><code>docker-compose build</code><br>运行当前内容，并重新构建<br><code>docker-compose up -d --build</code>   </p>
</li>
</ol>
<hr>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="运行docker-rmi-IMAGE-ID-报错"><a href="#运行docker-rmi-IMAGE-ID-报错" class="headerlink" title="运行docker rmi [IMAGE ID]报错"></a>运行<code>docker rmi [IMAGE ID]</code>报错</h2><ol>
<li>错误1<br><code>unable to delete b8dfe9ade316 (must be forced) - image is referenced in multiple repositories</code><br>错误原因：查看镜像发现，同一个IMAGE ID被多个REPOSITORY引用<br><img src="https://s1.ax1x.com/2020/10/22/BkiIKI.png"><br>解决方法<br><code>docker rmi tomcat:8.5</code><br>再次运行<code>docker rmi [IMAGE ID]</code>即可   </li>
<li>错误2<br><code>unable to delete b8dfe9ade316 (must be forced) - image is being used by stopped container fef1a1b37057</code><br>错误原因：即要删除的该镜像,被容器fef1a1b37057所引用了<br>解决方法  </li>
</ol>
<ul>
<li>执行<code>docker ps -a</code>查看所有容器记录（包括未运行的容器），并查看那些容器是使用了这个要删除的镜像    </li>
<li>执行命令<code>docker rm container_ID</code>删除这个容器   </li>
<li>再次运行<code>docker rmi [IMAGE ID]</code>即可   </li>
</ul>
]]></content>
      <categories>
        <category>项目开发基础</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习</title>
    <url>/2020/10/21/deeplearning/</url>
    <content><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p>计算机视觉  </p>
<blockquote>
<p>CNN:卷积神经网络    </p>
</blockquote>
<p>序列数据，如音频(一维时间序列)  </p>
<blockquote>
<p>RNN:循环神经网络<br>RNNS：更复杂的循环神经网络  </p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/10/21/BCFxwF.png" alt="样例图"><br>结构化数据与非结构化数据<br><img src="https://s1.ax1x.com/2020/10/21/BCkbAe.png" alt="结构化数据与非结构化数据 "></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Go</title>
    <url>/2020/10/29/go/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Go语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>初探JavaScript</title>
    <url>/2020/09/05/js/</url>
    <content><![CDATA[<h1 id="JavaScript输出"><a href="#JavaScript输出" class="headerlink" title="JavaScript输出"></a>JavaScript输出</h1><p>JavaScript通过下面方式输出数据   </p>
<ul>
<li>使用 window.alert() 弹出警告框。</li>
<li>使用 document.write() 方法将内容写到 HTML 文档中   <blockquote>
<p>如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。  </p>
</blockquote>
</li>
<li>使用 innerHTML 写入到 HTML 元素。  </li>
<li>使用 console.log() 写入到浏览器的控制台。  <h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;我的第一个javacript&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;我是一个标题&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;我是第一段文字&lt;/p&gt;</span><br><span class="line">&lt;!-- 弹出警告框--&gt;</span><br><span class="line">&lt;script&gt;<span class="built_in">window</span>.alert(<span class="string">&quot;error:请刷新页面&quot;</span>)&lt;/script&gt;</span><br><span class="line">&lt;!-- 替换第二段文字--&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;demo&quot;</span>&gt;我是第二段文字,我tm要没了&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML=<span class="string">&quot;我tm是新的第二段文字&quot;</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!-- 写入到 HTML 元素。--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="built_in">Date</span>())</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;!-- 整个 HTML 页面将被覆盖--&gt;</span><br><span class="line">&lt;button onclick=<span class="string">&quot;clickme()&quot;</span>&gt;点我点我&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clickme</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="built_in">Date</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!-- 写入到浏览器的控制台--&gt;</span><br><span class="line">&lt;p&gt;使用F12查看&lt;/p&gt;</span><br><span class="line">&lt;script&gt;<span class="built_in">console</span>.log(<span class="string">&quot;error:请关闭控制台😉🐱‍🏍&quot;</span>)&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript学习</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV学习</title>
    <url>/2020/09/21/opencv/</url>
    <content><![CDATA[<h1 id="读取、显示和保存图片"><a href="#读取、显示和保存图片" class="headerlink" title="读取、显示和保存图片"></a>读取、显示和保存图片</h1><h2 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imread(<span class="string">&#x27;图像名称&#x27;</span>，<span class="string">&#x27;可选参数&#x27;</span>)   </span><br></pre></td></tr></table></figure>
<h3 id="可选参数决定读入图像的模式："><a href="#可选参数决定读入图像的模式：" class="headerlink" title="可选参数决定读入图像的模式："></a>可选参数决定读入图像的模式：</h3><blockquote>
<p>0：读入的为灰度图像（即使图像为彩色的）<br>1：读入的图像为彩色的（默认）</p>
</blockquote>
<h2 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h2><ol>
<li>使用OpenCV方式显示<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">&#x27;input image&#x27;</span>,src)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></li>
<li>使用matplotlib库包中的pyplot子包来显示  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.imshow(img, <span class="string">&#x27;gray&#x27;</span>) <span class="comment">#必须规定为显示的为什么图像</span></span><br><span class="line">plt.xticks([]),plt.yticks([]) <span class="comment">#隐藏坐标线 </span></span><br><span class="line">plt.show() <span class="comment">#显示出来，不要也可以，但是一般都要了</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>opencv的接口使用BGR，而matplotlib.pyplot 则是RGB模式</li>
<li>cv2读入的是BGR模式，在opencv里面存储的是BGR，所以img用opencv输出就是正常颜色</li>
<li>matplotlib.pyplot是RGB模式，当用cv读入，直接用matplotlib.pyplot输出，颜色就变了，所以需要调整颜色的顺序，就变成了img2  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&#x27;D:/1.jpg&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">b,g,r = cv.split(img)</span><br><span class="line">img2 = cv.merge([r,g,b])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">&quot;保存路径&quot;</span>, src)  </span><br></pre></td></tr></table></figure>
<h3 id="imwrite的第三个参数"><a href="#imwrite的第三个参数" class="headerlink" title="imwrite的第三个参数"></a>imwrite的第三个参数</h3><ul>
<li>对于JPEG，其表示的是图像的质量，用0-100的整数表示，默认为95。 注意，cv2.IMWRITE_JPEG_QUALITY类型为Long，必须转换成int。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">&quot;保存路径&quot;</span>, src,[int(cv2.IMWRITE_JPEG_QUALITY), <span class="number">5</span>])</span><br></pre></td></tr></table></figure></li>
<li>对于PNG，第三个参数表示的是压缩级别。cv2.IMWRITE_PNG_COMPRESSION，从0到9,压缩级别越高，图像尺寸越小。默认级别为3。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">&quot;保存路径&quot;</span>, src, [int(cv2.IMWRITE_PNG_COMPRESSION), <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#读取图片</span></span><br><span class="line">src =cv.imread(<span class="string">&quot;D:/1.jpg&quot;</span>,<span class="number">1</span>) </span><br><span class="line">cv.namedWindow(<span class="string">&quot;input image&quot;</span>,cv.WINDOW_AUTOSIZE)</span><br><span class="line"><span class="comment">#用cv2显示图片</span></span><br><span class="line">cv.imshow(<span class="string">&quot;input image&quot;</span>,src)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"><span class="comment">#用plt显示图片</span></span><br><span class="line">plt.imshow(src, <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment">#保存图片</span></span><br><span class="line">cv.imwrite(<span class="string">&quot;D:/demo.jpg&quot;</span>, src,[int(cv.IMWRITE_JPEG_QUALITY), <span class="number">100</span>])</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="简单图形绘制"><a href="#简单图形绘制" class="headerlink" title="简单图形绘制"></a>简单图形绘制</h1><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h2 id="线形"><a href="#线形" class="headerlink" title="线形"></a>线形</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = np.zeros((<span class="number">512</span>, <span class="number">512</span>), np.uint8)</span><br><span class="line"><span class="comment">#生成一个灰色图像</span></span><br><span class="line">cv.line(img, (<span class="number">0</span>, <span class="number">0</span>), (<span class="number">511</span>, <span class="number">511</span>), <span class="number">255</span>, <span class="number">5</span>)</span><br><span class="line">plt.imshow(img, <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.show()  </span><br><span class="line"> <span class="comment"># 生成一个彩色图像</span></span><br><span class="line">src = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8) </span><br><span class="line">cv.line(src, (<span class="number">0</span>, <span class="number">0</span>), (<span class="number">511</span>, <span class="number">511</span>), (<span class="number">155</span>, <span class="number">55</span>, <span class="number">55</span>), <span class="number">5</span>)</span><br><span class="line">plt.imshow(src, <span class="string">&#x27;brg&#x27;</span>)</span><br><span class="line">plt.show() </span><br></pre></td></tr></table></figure>
<p>说明：</p>
<blockquote>
<p>(0, 0)   起点<br>   (511, 511)   终点<br>    (155, 55, 55)   颜色<br>    5   线宽</p>
</blockquote>
<h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)  </span><br><span class="line">cv.rectangle(img, (<span class="number">20</span>, <span class="number">20</span>), (<span class="number">411</span>, <span class="number">411</span>), (<span class="number">55</span>, <span class="number">255</span>, <span class="number">155</span>), <span class="number">5</span>)</span><br><span class="line">plt.imshow(img, <span class="string">&#x27;brg&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>说明：  </p>
<blockquote>
<p>(20, 20) 顶点<br>  (411, 411)    对角顶点  </p>
</blockquote>
<h2 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)  </span><br><span class="line">cv.circle(img, (<span class="number">200</span>, <span class="number">200</span>), <span class="number">150</span>, (<span class="number">55</span>, <span class="number">255</span>, <span class="number">155</span>), <span class="number">5</span>)  </span><br><span class="line">plt.imshow(img, <span class="string">&#x27;brg&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>说明：   </p>
<blockquote>
<p>(200, 200)   圆心<br>  150   半径</p>
</blockquote>
<h2 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)<span class="comment">#生成一个空彩色图像</span></span><br><span class="line">cv2.ellipse(img,(<span class="number">256</span>,<span class="number">256</span>),(<span class="number">150</span>,<span class="number">100</span>),<span class="number">30</span>,<span class="number">10</span>,<span class="number">370</span>,(<span class="number">55</span>, <span class="number">255</span>, <span class="number">155</span>), <span class="number">5</span>,<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#注意最后一个参数-1，表示对图像进行填充，默认是不填充的，如果去掉，只有椭圆轮廓了</span></span><br><span class="line">plt.imshow(img,<span class="string">&#x27;brg&#x27;</span>)  </span><br></pre></td></tr></table></figure>
<p>说明：  </p>
<blockquote>
<p>(256,256)中心坐标<br>  (150,100)轴长度<br>  30    偏转角度<br>  10  起点角度<br>  370   终点角度</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OpenCV学习</tag>
      </tags>
  </entry>
  <entry>
    <title>一个丑陋的3D小人</title>
    <url>/2020/08/31/three-js-learn/</url>
    <content><![CDATA[<h1 id="一个丑陋的3D小人"><a href="#一个丑陋的3D小人" class="headerlink" title="一个丑陋的3D小人"></a>一个丑陋的3D小人</h1><p>第一次接触three.js，技术还十分辣鸡🤣，一通复制粘贴改参数，终于画出来一个丑陋的3D小人，具体代码如下。<br>想要运行此代码，要引入three.js文件，<a href="https://github.com/mrdoob/three.js">three.js文件下载地址</a>。</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://s1.ax1x.com/2020/09/05/wVrY1U.png" alt="正视图" title="正视图"><br><img src="https://s1.ax1x.com/2020/09/05/wVranJ.png" alt="左视图" title="左视图"><br><img src="https://s1.ax1x.com/2020/09/05/wVrBA1.png" alt="俯视图" title="俯视图"></p>
<h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;一个丑陋的<span class="number">3</span>D小人&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        margin: <span class="number">0</span>;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">      <span class="comment">/* 隐藏body窗口区域滚动条 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;!--引入three.js三维引擎--&gt;</span><br><span class="line">    &lt;!--将这里的文件路径改为你的文件路径--&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;./three.js/build/three.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;./three.js/examples/js/controls/OrbitControls.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建场景对象Scene</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建网格模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//腿</span></span><br><span class="line"><span class="keyword">var</span> geometry1 = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">20</span>, <span class="number">5</span>, <span class="number">150</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material1 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh1 = <span class="keyword">new</span> THREE.Mesh(geometry1, material1); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">mesh1.position.set(<span class="number">0</span>,<span class="number">-150</span>,<span class="number">45</span>)</span><br><span class="line">scene.add(mesh1); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头</span></span><br><span class="line"><span class="keyword">var</span> geometry2 = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">60</span>, <span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line"><span class="keyword">var</span> material2 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xff00ff</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh2 = <span class="keyword">new</span> THREE.Mesh(geometry2, material2); </span><br><span class="line">mesh2.translateY(<span class="number">160</span>); </span><br><span class="line">scene.add(mesh2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 身体</span></span><br><span class="line"><span class="keyword">var</span> geometry3 = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">60</span>, <span class="number">80</span>, <span class="number">200</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material3 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xffff00</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh3 = <span class="keyword">new</span> THREE.Mesh(geometry3, material3); </span><br><span class="line"><span class="comment">// mesh3.translateX(120); </span></span><br><span class="line">mesh3.position.set(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">scene.add(mesh3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//腿</span></span><br><span class="line"><span class="keyword">var</span> geometry4 = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">20</span>, <span class="number">5</span>, <span class="number">150</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material4 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh4 = <span class="keyword">new</span> THREE.Mesh(geometry4, material4); </span><br><span class="line">mesh4.position.set(<span class="number">0</span>,<span class="number">-150</span>,<span class="number">-45</span>);</span><br><span class="line">scene.add(mesh4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//胳膊</span></span><br><span class="line"><span class="keyword">var</span> geometry5 = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">20</span>, <span class="number">5</span>, <span class="number">150</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material5 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh5 = <span class="keyword">new</span> THREE.Mesh(geometry5, material5); </span><br><span class="line">mesh5.rotateX(<span class="built_in">Math</span>.PI / <span class="number">4</span>);</span><br><span class="line">mesh5.position.set(<span class="number">0</span>,<span class="number">20</span>,<span class="number">-90</span>);</span><br><span class="line">scene.add(mesh5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//胳膊</span></span><br><span class="line"><span class="keyword">var</span> geometry6 = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">20</span>, <span class="number">5</span>, <span class="number">150</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material6 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh6 = <span class="keyword">new</span> THREE.Mesh(geometry6, material6); </span><br><span class="line">mesh6.rotateX(<span class="built_in">Math</span>.PI / <span class="number">-4</span>);</span><br><span class="line">mesh6.position.set(<span class="number">0</span>,<span class="number">20</span>,<span class="number">90</span>);</span><br><span class="line">scene.add(mesh6);</span><br><span class="line"></span><br><span class="line"><span class="comment">//眼睛</span></span><br><span class="line"><span class="keyword">var</span> geometry7 = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">10</span>, <span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line"><span class="keyword">var</span> material7 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xCC3366</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh7 = <span class="keyword">new</span> THREE.Mesh(geometry7, material7); </span><br><span class="line">mesh7.position.set(<span class="number">40</span>,<span class="number">180</span>,<span class="number">30</span>);</span><br><span class="line">scene.add(mesh7);</span><br><span class="line"></span><br><span class="line"><span class="comment">//眼睛</span></span><br><span class="line"><span class="keyword">var</span> geometry8 = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">10</span>, <span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line"><span class="keyword">var</span> material8 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xCC3366</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh8 = <span class="keyword">new</span> THREE.Mesh(geometry8, material8); </span><br><span class="line">mesh8.position.set(<span class="number">40</span>,<span class="number">180</span>,<span class="number">-30</span>); </span><br><span class="line">scene.add(mesh8);</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼻子</span></span><br><span class="line"><span class="keyword">var</span> geometry9 = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">10</span>, <span class="number">2.5</span>, <span class="number">50</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material9 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x9999FF</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh9 = <span class="keyword">new</span> THREE.Mesh(geometry9, material9); </span><br><span class="line">mesh9.rotateZ(<span class="built_in">Math</span>.PI / <span class="number">2</span>);</span><br><span class="line">mesh9.position.set(<span class="number">60</span>,<span class="number">165</span>,<span class="number">0</span>);</span><br><span class="line">scene.add(mesh9);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下均为头发</span></span><br><span class="line"><span class="keyword">var</span> geometry10 = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material10 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x99FF00</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh10 = <span class="keyword">new</span> THREE.Mesh(geometry10, material10); </span><br><span class="line">mesh10.position.set(<span class="number">0</span>,<span class="number">240</span>,<span class="number">0</span>);</span><br><span class="line">scene.add(mesh10);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> geometry11 = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material11 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x99FF00</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh11 = <span class="keyword">new</span> THREE.Mesh(geometry10, material10); </span><br><span class="line">mesh11.position.set(<span class="number">0</span>,<span class="number">240</span>,<span class="number">0</span>);</span><br><span class="line">scene.add(mesh11);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> geometry12 = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material12 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x99FF00</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh12 = <span class="keyword">new</span> THREE.Mesh(geometry12, material12);</span><br><span class="line">mesh12.rotateX(<span class="built_in">Math</span>.PI / <span class="number">-3</span>);</span><br><span class="line">mesh12.position.set(<span class="number">0</span>,<span class="number">210</span>,<span class="number">-40</span>);</span><br><span class="line">scene.add(mesh12);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> geometry13 = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material13 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x99FF00</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh13 = <span class="keyword">new</span> THREE.Mesh(geometry13, material13); </span><br><span class="line">mesh13.rotateX(<span class="built_in">Math</span>.PI / <span class="number">3</span>);</span><br><span class="line">mesh13.position.set(<span class="number">0</span>,<span class="number">210</span>,<span class="number">40</span>);</span><br><span class="line">scene.add(mesh13);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 光源设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//辅助坐标系</span></span><br><span class="line">    <span class="keyword">var</span> axisHelper = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">250</span>);</span><br><span class="line">    scene.add(axisHelper);</span><br><span class="line">    <span class="comment">//点光源</span></span><br><span class="line">    <span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span><br><span class="line">    point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span><br><span class="line">    scene.add(point); <span class="comment">//点光源添加到场景中</span></span><br><span class="line">    <span class="comment">//环境光</span></span><br><span class="line">    <span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x444444</span>);</span><br><span class="line">    scene.add(ambient);</span><br><span class="line">    <span class="comment">// console.log(scene)</span></span><br><span class="line">    <span class="comment">// console.log(scene.children)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 相机设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span><br><span class="line">    <span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span><br><span class="line">    <span class="keyword">var</span> s = <span class="number">200</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span><br><span class="line">    <span class="comment">//创建相机对象</span></span><br><span class="line">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">    camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span><br><span class="line">    camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建渲染器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line">    renderer.setSize(width, height);<span class="comment">//设置渲染区域尺寸</span></span><br><span class="line">    renderer.setClearColor(<span class="number">0xb9d3ff</span>, <span class="number">1</span>); <span class="comment">//设置背景颜色</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//body元素中插入canvas对象</span></span><br><span class="line">    <span class="comment">//执行渲染操作   指定场景、相机作为参数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    renderer.render(scene,camera);<span class="comment">//执行渲染操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  render();</span><br><span class="line">  <span class="keyword">var</span> controls = <span class="keyword">new</span> THREE.OrbitControls(camera,renderer.domElement);<span class="comment">//创建控件对象</span></span><br><span class="line">  controls.addEventListener(<span class="string">&#x27;change&#x27;</span>, render);<span class="comment">//监听鼠标、键盘事件</span></span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>three.js学习</tag>
      </tags>
  </entry>
</search>
